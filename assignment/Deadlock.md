#嵌入式系统导论实验
##Lab4：死锁
**1.实验截图**  
![deadlock](http://i.imgur.com/A0MF2Mi.png)
  
**2.产生死锁的四个必要条件**  
&emsp;a. 互斥条件：一个资源每次只能别一个进程使用。  
&emsp;b. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。  
&emsp;c. 不剥夺条件：进程已获得的资源，在未使用之前，不能强行剥夺。  
&emsp;d. 循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。  
  
**3.对实验产生死锁的解释**  
&emsp;1. 互斥条件：用synchronized关键字修饰的代码块能保证同一时刻最多只有一个线程执行该段代码，当一个线程访问object的一个synchronized同步代码块时，其他线程对object中所有其他synchronized同步代码块的访问将被阻塞。
&emsp;2. 请求与保持条件与不剥夺条件均由操作系统决定，一般操作系统都符合这两个条件，以确保相应线程所获得资源不被剥夺。  
&emsp;3. 循环等待条件：当主线程跳出while循环，执行了methodA函数时，假如还没开始调用last函数就让出cpu,调度了run函数中的methodB函数,此时methodB函数想调用object a 的last函数时发现sychronized资源被占用了,让出cpu，主线程占用cpu资源，想调用object b 的last函数时发现object b的sychronized资源被占用了，让出cpu资源,...周而复始。此时则满足循环等待的条件。  
&emsp;4. 此时则产生了死锁，要达到这种实验效果需要对while循环中的count进行调试，改变主线程调用methodA的时间，以找到还没调用object b的last函数时就调度了线程run的时机,以此产生死锁。windows比较容易达到这种实验效果，而ubuntu比较不容易产生效果，因为linux系统有一些避免死锁的机制，例如破坏请求与保持条件，当进程因请求资源而阻塞时，对已获得资源进行释放。
